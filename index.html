<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>NEON PINBALL — Hyperflow</title>
<style>
  :root{
    --bg:#0a0c10;
    --panel:#0f1320;
    --ink:#cdd7ff;
    --muted:#6d7599;
    --accent:#7ef9c6;
    --accent2:#8ab3ff;
    --hot:#ff6bd6;
    --gold:#ffd166;
    --danger:#ff5f5f;
    --ok:#6fffa8;
    --cyan:#68e1ff;
    --purple:#9a7bff;
  }
  html,body{
    height:100%;
    margin:0;
   background: var(--bg);
    color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue",
                 "Hiragino Kaku Gothic ProN", "Noto Sans JP", Arial, "Apple Color Emoji",
                 "Segoe UI Emoji";
    overflow:hidden;
  }
  .hud{
    position:fixed;
    top:12px; left:12px; right:12px;
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    pointer-events:none;
  }
  .badge{
    background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.25));
    border:1px solid rgba(255,255,255,0.08);
    padding:10px 14px;
    border-radius:12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);
    backdrop-filter: blur(6px);
    pointer-events:auto;
  }
  .badge strong{ letter-spacing:0.02em; color:var(--ink); }
  .row{ display:flex; gap:10px; align-items:center; }
  .pill{
    padding:6px 10px; border-radius:999px; font-weight:600; font-size:12px;
    border:1px solid rgba(255,255,255,0.08);
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
  }
  .pill.good{ color:var(--ok); border-color:rgba(111,255,168,0.35); box-shadow:0 0 12px rgba(111,255,168,0.35); }
  .pill.hot{ color:var(--hot); border-color:rgba(255,107,214,0.35); box-shadow:0 0 12px rgba(255,107,214,0.35); }
  .pill.cyan{ color:var(--cyan); border-color:rgba(104,225,255,0.35); box-shadow:0 0 12px rgba(104,225,255,0.35); }
  .pill.gold{ color:var(--gold); border-color:rgba(255,209,102,0.35); box-shadow:0 0 12px rgba(255,209,102,0.35); }
  .right{ display:flex; gap:8px; align-items:center; }
  .btn{
    pointer-events:auto;
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.35));
    border:1px solid rgba(255,255,255,0.1);
    color:var(--ink);
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer; user-select:none;
    transition: transform .08s ease, box-shadow .2s ease;
  }
  .btn:hover{ transform: translateY(-1px); box-shadow: 0 8px 24px rgba(0,0,0,0.35); }
  .hint{ color:var(--muted); font-size:12px; }
  .wrap{
    position:fixed; inset:0; display:grid; place-items:center;
  }
  canvas{
    width:min(92vw, 860px);
    height:auto;
    aspect-ratio: 800 / 1100;
    border-radius:24px;
    background:
      radial-gradient(300px 280px at 400px 260px, rgba(120,180,255,0.08), rgba(0,0,0,0) 60%),
      linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.2)),
      #0c0f18;
    box-shadow:
      0 40px 80px rgba(0,0,0,0.55),
      inset 0 0 0 2px rgba(255,255,255,0.06),
      inset 0 0 80px rgba(130,180,255,0.06);
  }
  .footer{
    position:fixed; bottom:10px; left:12px; right:12px;
    display:flex; align-items:center; justify-content:space-between;
    color:var(--muted); font-size:12px;
    pointer-events:none;
  }
  .footer .keys{ letter-spacing:0.02em; }
  .flash{
    position:fixed; inset:0; pointer-events:none;
    background: radial-gradient(600px 600px at 50% 60%, rgba(255,255,255,0.12), rgba(255,255,255,0));
    opacity:0; transition: opacity .25s ease;
  }
  .flash.on{ opacity:1; }
  .toast{
    position:fixed; left:50%; top:15%;
    transform: translate(-50%, -50%) scale(0.98);
    opacity:0; pointer-events:none;
    padding:10px 14px; border-radius:999px;
    background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.35));
    border:1px solid rgba(255,255,255,0.1);
    color:var(--ink); font-weight:700; letter-spacing:0.1em; font-size:14px;
    text-transform: uppercase;
    filter: drop-shadow(0 10px 30px rgba(0,0,0,0.4));
    transition: opacity .25s ease, transform .25s ease;
  }
  .toast.show{ opacity:1; transform: translate(-50%, -50%) scale(1); }

</style>
<div id="touchLeft" style="position:fixed;left:0;top:0;width:50%;height:100%;z-index:10;"></div>
<div id="touchRight" style="position:fixed;right:0;top:0;width:50%;height:100%;z-index:10;"></div>
<div id="touchLaunch" style="
  position:fixed;bottom:20px;left:50%;transform:translateX(-50%);
  width:100px;height:100px;border-radius:50%;
  background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);
  z-index:11;display:flex;align-items:center;justify-content:center;
  color:white;font-weight:bold;font-size:14px;user-select:none;
">LAUNCH</div>

</head>
<body>
  <div class="hud">
    <div class="row">
      <div class="badge">
        <div class="row">
          <strong>SCORE</strong>
          <span id="score" class="pill good">000,000</span>
          <span id="mult" class="pill hot">x1</span>
        </div>
      </div>
      <div class="badge">
        <div class="row">
          <strong>TIME</strong>
          <span id="time" class="pill cyan">180.0s</span>
          <span id="state" class="pill gold">READY</span>
        </div>
      </div>
      <div class="badge">
        <div class="row">
          <strong>RANK</strong>
          <span id="rank" class="pill">NOVICE</span>
        </div>
      </div>
    </div>
    <div class="right">
      <div class="badge hint">← 左フリッパー / → 右フリッパー / スペースで発射</div>
      <div class="btn" id="resetBtn">RESET</div>
      <div class="btn" id="muteBtn">SOUND: ON</div>
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="800" height="1100"></canvas>
  </div>

  <div class="footer">
    <div class="keys">WORDS: GLOW / VIBE / NOVA / ECHO / FLUX / AURA / MYTH / LUSH / MINT / VOID</div>
    <div>Hyperflow: 全点灯で解放（スロー＋x3＋セーバー＋レインボー）</div>
  </div>

  <div class="flash" id="flash"></div>
  <div class="toast" id="toast">HYPERFLOW</div>


<script>
(()=>{
'use strict';

/* =========================
   Audio (WebAudio, no mp3)
   ========================= */
const AudioSys = (()=>{
  const ctx = new (window.AudioContext||window.webkitAudioContext)();
  let muted = false;
  const master = ctx.createGain(); master.gain.value = 0.18; master.connect(ctx.destination);

  const env = (gain, tA=0.005, tD=0.12, sus=0.0)=>{
    const now = ctx.currentTime;
    gain.gain.cancelScheduledValues(now);
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(1.0, now + tA);
    gain.gain.exponentialRampToValueAtTime(Math.max(0.0001,sus), now + tA + tD);
  };

  const beep = (f=440, dur=0.12, type='sine', detune=0, tA=0.003, tD=0.08, sus=0.0001)=>{
    if(muted) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f1 = ctx.createBiquadFilter(); f1.type='lowpass'; f1.frequency.value = 10000;
    o.type = type; o.frequency.value = f; o.detune.value = detune;
    o.connect(g); g.connect(f1); f1.connect(master);
    env(g, tA, tD, sus);
    const now = ctx.currentTime;
    o.start(now);
    o.stop(now + dur);
  };

  const click = ()=>{
    beep(180, .04, 'square', -600, .001, .04);
  };

  const thump = ()=>{
    if(muted) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type='sine'; o.frequency.setValueAtTime(160, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(60, ctx.currentTime + 0.08);
    g.gain.setValueAtTime(0.001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(1.0, ctx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
    o.connect(g); g.connect(master);
    o.start(); o.stop(ctx.currentTime + 0.14);
  };

  const chord = (root=440, steps=[0,4,7,12], t=0.35)=>{
    if(muted) return;
    const now = ctx.currentTime;
    steps.forEach((st,i)=>{
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type='triangle';
      o.frequency.value = root * Math.pow(2, st/12);
      o.connect(g); g.connect(master);
      g.gain.setValueAtTime(0.0001, now + i*0.03);
      g.gain.exponentialRampToValueAtTime(0.8, now + i*0.03 + 0.05);
      g.gain.exponentialRampToValueAtTime(0.0001, now + i*0.03 + t);
      o.start(now + i*0.03); o.stop(now + i*0.03 + t + 0.01);
    });
  };

  const arpy = (base=330, count=6)=>{
    if(muted) return;
    const seq = Array.from({length:count}, (_,i)=> base * Math.pow(2, (i%5)/12));
    seq.forEach((f, i)=> beep(f, 0.08, 'square', 0, 0.002, 0.05, 0.0001 + i*0.0001));
  };

  const setMuted = v=> muted = v;
  const isMuted = ()=> muted;
  const resume = ()=> ctx.resume();
  return {beep, click, thump, chord, arpy, setMuted, isMuted, resume};
})();

/* =========================
   Utilities
   ========================= */
const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
const lerp = (a,b,t)=> a + (b-a)*t;
const rand = (a,b)=> a + Math.random()*(b-a);
const nowMs = ()=> performance.now();

/* =========================
   Canvas setup
   ========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;


const flashEl = document.getElementById('flash');
const toast = document.getElementById('toast');

const uiScore = document.getElementById('score');
const uiMult  = document.getElementById('mult');
const uiTime  = document.getElementById('time');
const uiState = document.getElementById('state');
const uiRank  = document.getElementById('rank');
const resetBtn= document.getElementById('resetBtn');
const muteBtn = document.getElementById('muteBtn');

/* =========================
   Game state
   ========================= */
const GRAVITY = 0.45;
const FRICTION = 0.998;
const RESTITUTION = 0.88;
const DT_BIAS = 1/60;

let game = {
  running:false,
  timeLeft:180.0,
  score:0,
  mult:1,
  rank:"NOVICE",
  combo:0,
  hyper:false,
  hyperTimer:0,
  spawnReady:true,
  balls:[],
  particles:[],
  shakes:0,
  litWords: new Set(),
  allWords:["GLOW","VIBE","NOVA","ECHO","FLUX","AURA","MYTH","LUSH","MINT","VOID"],
  lanes:[],
  bumpers:[],
  flippers:[],
  walls:[],
  spawner:{x:730, y:940, ready:true},
};

/* =========================
   Input
   ========================= */
let keys = { left:false, right:false, space:false };
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==="ArrowLeft"){ keys.left=true; e.preventDefault(); }
  if(e.key==="ArrowRight"){ keys.right=true; e.preventDefault(); }
  if(e.code==="Space"){ keys.space=true; e.preventDefault(); }
  // resume audio on first key
  AudioSys.resume();
});
window.addEventListener('keyup', e=>{
  if(e.key==="ArrowLeft"){ keys.left=false; }
  if(e.key==="ArrowRight"){ keys.right=false; }
  if(e.code==="Space"){ keys.space=false; }
});

// タッチ操作
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');
const touchLaunch = document.getElementById('touchLaunch');

function bindTouch(el, onDown, onUp){
  el.addEventListener('touchstart', e=>{ e.preventDefault(); onDown(); });
  el.addEventListener('touchend', e=>{ e.preventDefault(); onUp(); });
}

bindTouch(touchLeft, ()=> keys.left = true, ()=> keys.left = false);
bindTouch(touchRight, ()=> keys.right = true, ()=> keys.right = false);
bindTouch(touchLaunch, ()=> keys.space = true, ()=> keys.space = false);

/* =========================
   Geometry helpers
   ========================= */
function lineCircleIntersect(x1,y1,x2,y2, cx,cy,r){
  const vx = x2-x1, vy=y2-y1;
  const wx = cx-x1, wy=cy-y1;
  const len2 = vx*vx+vy*vy || 1;
  const t = clamp((wx*vx + wy*vy)/len2, 0, 1);
  const px = x1 + vx*t, py = y1 + vy*t;
  const dx = cx - px, dy = cy - py;
  return (dx*dx + dy*dy) <= r*r;
}
function reflectBallFromLine(ball, x1,y1,x2,y2, bounce=RESTITUTION){
  // compute normal
  const lx = x2-x1, ly=y2-y1;
  const nx = -ly, ny=lx;
  const nlen = Math.hypot(nx,ny) || 1;
  const ux = nx/nlen, uy=ny/nlen;
  const dot = ball.vx*ux + ball.vy*uy;
  if(dot > 0) return; // moving away
  ball.vx = ball.vx - (1+bounce)*dot*ux;
  ball.vy = ball.vy - (1+bounce)*dot*uy;
}
function pushOutFromLine(ball, x1,y1,x2,y2){
  const vx = x2-x1, vy=y2-y1;
  const wx = ball.x - x1, wy = ball.y - y1;
  const t = clamp((wx*vx + wy*vy)/(vx*vx+vy*vy), 0, 1);
  const px = x1 + vx*t, py = y1 + vy*t;
  const dx = ball.x - px, dy = ball.y - py;
  const dist = Math.hypot(dx,dy) || 1;
  const overlap = ball.r - dist;
  if(overlap>0){
    const ux = dx/dist, uy = dy/dist;
    ball.x += ux*overlap;
    ball.y += uy*overlap;
  }
}
function circleBounce(ball, cx,cy, r, bounce=RESTITUTION){
  const dx = ball.x - cx, dy = ball.y - cy;
  const dist = Math.hypot(dx,dy) || 1;
  const overlap = (ball.r + r) - dist;
  if(overlap>0){
    const ux = dx/dist, uy = dy/dist;
    ball.x += ux*overlap;
    ball.y += uy*overlap;
    const dot = ball.vx*ux + ball.vy*uy;
    ball.vx -= (1+bounce)*dot*ux;
    ball.vy -= (1+bounce)*dot*uy;
    return true;
  }
  return false;
}

/* =========================
   Entities
   ========================= */
function makeBall(){
  return {
    x: game.spawner.x, y: game.spawner.y,
    vx: rand(-1,1)*0.5, vy: -10,
    r: 13,
    trail: [],
    alive:true,
  };
}
function makeBumper(x,y, r, word, hue){
  return {x,y,r, word, hue, lit:false, pulse:0};
}
function makeLane(x1,y1,x2,y2, word, hue){
  return {x1,y1,x2,y2, word, hue, lit:false, glow:0};
}
function makeFlipper(px,py, len, angleRest, side, upper=false){
  return {
    px,py, len,
    angle: angleRest,
    angleRest,
    angleActive: angleRest + (side==='left'? -38 : 38) * (upper?0.9:1),
    side, upper,
    speed: 0,
    isActive: false,
  };
}

/* =========================
   Build table
   ========================= */
function buildTable(){
  game.walls.length = 0;
  // Outer walls (polygon lines)
  const border = [
    [80,1050, 720,1050],
    [80,1050, 80,120],
    [80,120, 400,40],
    [400,40, 720,120],
    [720,120, 720,1050],
  ];
  border.forEach(([x1,y1,x2,y2])=> game.walls.push({x1,y1,x2,y2, bounce:0.95}));

  // Gates near drain
  game.walls.push({x1:80,y1:900,x2:300,y2:1030,bounce:0.9});
  game.walls.push({x1:720,y1:900,x2:500,y2:1030,bounce:0.9});

  // Bumpers with words
  const words = game.allWords.slice();
  const positions = [
    [220,240],[400,210],[580,240],
    [260,360],[540,360],
    [220,500],[400,540],[580,500],
    [300,720],[500,720]
  ];
  game.bumpers = positions.map((p,i)=>{
    const hue = (i*36)%360;
    return makeBumper(p[0], p[1], 36, words[i], hue);
  });

  // Lanes (word lanes) — also lightable
  game.lanes = [
    makeLane(130,160, 250,260, "GLOW", 180),
    makeLane(550,160, 670,260, "VIBE", 200),
    makeLane(150,420, 310,520, "NOVA", 240),
    makeLane(490,420, 650,520, "ECHO", 260),
  ];

  // Flippers (two per side: lower + upper)
  // Lower left
  game.flippers.push(makeFlipper(250,980, 120, -18, 'left', false));
  // Upper left
  game.flippers.push(makeFlipper(260,770, 100, -12, 'left', true));
  // Lower right
  game.flippers.push(makeFlipper(550,980, 120, 198, 'right', false));
  // Upper right
  game.flippers.push(makeFlipper(540,770, 100, 192, 'right', true));
}

/* =========================
   Particles / Confetti
   ========================= */
function spawnSpark(x,y, color){
  for(let i=0;i<10;i++){
    game.particles.push({
      x,y,
      vx: rand(-2,2), vy: rand(-3, -0.5),
      life: rand(0.4,0.9),
      size: rand(1.5,3),
      color,
      type:'spark'
    });
  }
}
function spawnConfetti(){
  const cx = W/2, cy = H*0.2;
  for(let i=0;i<140;i++){
    game.particles.push({
      x: cx + rand(-220,220),
      y: cy + rand(-40,60),
      vx: rand(-2.2,2.2),
      vy: rand(-3.5, -1.2),
      life: rand(0.8, 1.8),
      size: rand(2,4),
      color: `hsl(${Math.floor(rand(180,320))} 90% 65%)`,
      rot: rand(0,Math.PI*2),
      type:'confetti'
    });
  }
}

/* =========================
   Scoring / Rank
   ========================= */
function addScore(base){
  const s = Math.floor(base * game.mult);
  game.score += s;
  game.combo++;
  if(game.combo % 4 === 0){
    game.mult = clamp(game.mult + 0.25, 1, game.hyper? 6 : 4);
    pulseUI(uiMult);
  }
  if(game.score > 500000){ game.rank="ASCENDANT"; }
  else if(game.score > 200000){ game.rank="VIRTUOSO"; }
  else if(game.score > 80000){ game.rank="ADEPT"; }
  else if(game.score > 30000){ game.rank="APPRENTICE"; }
}
function pulseUI(el){
  el.style.transform='scale(1.08)';
  el.style.boxShadow='0 0 18px rgba(255,255,255,0.25)';
  setTimeout(()=>{ el.style.transform=''; el.style.boxShadow=''; }, 140);
}

/* =========================
   Hyperflow Skill
   ========================= */
function triggerHyperflow(){
  game.hyper = true;
  game.hyperTimer = 6.0;
  game.mult = 3;
  toast.textContent = "HYPERFLOW";
  toast.classList.add('show');
  setTimeout(()=> toast.classList.remove('show'), 1200);
  flashEl.classList.add('on'); setTimeout(()=> flashEl.classList.remove('on'), 260);
  spawnConfetti();
  AudioSys.chord(392, [0,7,12,19], 0.5);
  AudioSys.arpy(330, 8);
}

/* =========================
   Spawner
   ========================= */
function maybeSpawnBall(){
  if(!game.spawnReady) return;
  if(game.balls.length>0) return;
  if(!game.running) return;
  game.spawnReady=false;
  setTimeout(()=>{
    game.balls.push(makeBall());
    game.spawner.ready=false;
    setTimeout(()=> game.spawner.ready=true, 600);
  }, 400);
}

/* =========================
   Reset / Start
   ========================= */
function resetGame(){
  game.running = true;
  game.timeLeft = 180.0;
  game.score = 0;
  game.mult = 1;
  game.rank = "NOVICE";
  game.combo = 0;
  game.hyper = false;
  game.hyperTimer = 0;
  game.balls = [];
  game.particles = [];
  game.shakes = 0;
  game.litWords.clear();
  buildTable();
  maybeSpawnBall();
  uiState.textContent = "PLAY";
}
resetBtn.addEventListener('click', ()=>{
  screenShake(10, 220);
  AudioSys.thump();
  resetGame();
});
muteBtn.addEventListener('click', ()=>{
  const m = !AudioSys.isMuted();
  AudioSys.setMuted(m);
  muteBtn.textContent = "SOUND: " + (m? "OFF" : "ON");
});

/* =========================
   Screen shake
   ========================= */
function screenShake(pwr=6, ms=140){
  game.shakes = Math.max(game.shakes, pwr);
  const t0 = nowMs();
  const tick = ()=>{
    const t = nowMs()-t0;
    if(t<ms){ requestAnimationFrame(tick); }
    else { game.shakes=0; }
  };
  requestAnimationFrame(tick);
}

/* =========================
   Main update
   ========================= */
let last = nowMs();
function update(){
  const now = nowMs();
  let dt = (now-last)/1000;
  last = now;

  // slow-mo when hyper
  const slow = game.hyper ? 0.5 : 1.0;
  dt = Math.min(0.033, dt) * slow;

  if(game.running){
    game.timeLeft -= dt/slow; // real-time countdown unaffected by slow-mo
    if(game.timeLeft <= 0){
      game.timeLeft = 0;
      game.running = false;
      uiState.textContent = "TIME UP";
      AudioSys.chord(196, [0,3,7], 0.9);
    }
  }

  // flippers input
  game.flippers.forEach(f=>{
    const target = (f.side==='left'? keys.left : keys.right) ? f.angleActive : f.angleRest;
    const diff = target - f.angle;
    f.speed = clamp(diff*0.4, -10, 10);
    f.angle += f.speed;
    f.isActive = Math.abs(diff) < 1.5 ? (target !== f.angleRest) : (f.speed !== 0);
  });

  // spawn if needed
  if(game.running && game.balls.length===0 && game.timeLeft>0){
    game.spawnReady = true;
    maybeSpawnBall();
  }

  // update particles
  game.particles = game.particles.filter(p=>{
    p.life -= dt;
    if(p.type==='spark' || p.type==='confetti'){
      p.vy += 0.2*dt*60;
      p.x += p.vx*dt*60;
      p.y += p.vy*dt*60;
    }
    return p.life>0;
  });

  // bumpers pulse
  game.bumpers.forEach(b=>{
    b.pulse = Math.max(0, b.pulse - dt*2.4);
  });
  // lanes glow decay
  game.lanes.forEach(l=> l.glow = Math.max(0, l.glow - dt*1.8));

  // hyperflow timer
  if(game.hyper){
    game.hyperTimer -= dt/slow;
    if(game.hyperTimer<=0){
      game.hyper=false;
      game.mult = Math.max(1, Math.floor(game.mult));
      toast.textContent = "HYPER END";
      toast.classList.add('show');
      setTimeout(()=> toast.classList.remove('show'), 900);
    }
  }

  // update balls
  for(const ball of game.balls){
    // gravity
    ball.vy += GRAVITY * dt*60;
    // motion
    ball.x += ball.vx * dt*60;
    ball.y += ball.vy * dt*60;

    // trail
    ball.trail.push({x:ball.x, y:ball.y, life:1});
    if(ball.trail.length>22) ball.trail.shift();
    ball.trail.forEach(t=> t.life -= dt* (game.hyper? 0.6 : 1.2));

    // walls
    for(const w of game.walls){
      if(lineCircleIntersect(w.x1,w.y1,w.x2,w.y2, ball.x,ball.y, ball.r)){
        pushOutFromLine(ball, w.x1,w.y1,w.x2,w.y2);
        reflectBallFromLine(ball, w.x1,w.y1,w.x2,w.y2, w.bounce??RESTITUTION);
        ball.vx *= FRICTION; ball.vy *= FRICTION;
        AudioSys.click();
      }
    }

    // bumpers
    for(const b of game.bumpers){
      if(circleBounce(ball, b.x,b.y, b.r, 1.05)){
        addScore(1200);
        b.lit = true; b.pulse = 1;
        game.litWords.add(b.word);
        spawnSpark(ball.x, ball.y, `hsl(${b.hue} 90% 65%)`);
        screenShake(4, 100);
        AudioSys.beep(440 * Math.pow(2, ((b.hue%48)/12)), 0.09, 'sawtooth', 0, 0.002, 0.06);
      }
    }

    // lanes
    for(const l of game.lanes){
      if(lineCircleIntersect(l.x1,l.y1,l.x2,l.y2, ball.x,ball.y, ball.r*0.9)){
        pushOutFromLine(ball, l.x1,l.y1,l.x2,l.y2);
        reflectBallFromLine(ball, l.x1,l.y1,l.x2,l.y2, 0.95);
        l.lit = true; l.glow = 1;
        game.litWords.add(l.word);
        addScore(800);
        AudioSys.beep(660, 0.07, 'triangle', 0, 0.002, 0.05);
      }
    }

    // flipper collision
    for(const f of game.flippers){
      const ax = f.px, ay=f.py;
      const bx = ax + Math.cos(f.angle * Math.PI/180) * f.len;
      const by = ay + Math.sin(f.angle * Math.PI/180) * f.len;

      if(lineCircleIntersect(ax,ay,bx,by, ball.x,ball.y, ball.r)){
        // push out then reflect
        pushOutFromLine(ball, ax,ay,bx,by);
        reflectBallFromLine(ball, ax,ay,bx,by, 0.98);
        // add flipper impulse
        const tipSpeed = f.speed*0.9;
        const nx = Math.cos((f.angle+90)*Math.PI/180);
        const ny = Math.sin((f.angle+90)*Math.PI/180);
        const impulse = (f.side==='left'? -1 : 1) * tipSpeed * (f.upper? 0.75 : 1.1);
        ball.vx += nx * impulse;
        ball.vy += ny * impulse - (f.upper? 0.2 : 0.0);
        addScore(f.upper? 120 : 200);
        AudioSys.thump();
      }
    }

    // drain
    if(ball.y > H+40){
      ball.alive=false;
      game.combo = 0; game.mult = Math.max(1, Math.floor(game.mult*0.9));
      AudioSys.beep(220, 0.2, 'sine', -200);
      setTimeout(()=> { game.spawnReady=true; maybeSpawnBall(); }, 500);
    }

    ball.vx = clamp(ball.vx, -22, 22);
    ball.vy = clamp(ball.vy, -28, 28);
  }
  game.balls = game.balls.filter(b=> b.alive);

  // all lit? — Hyperflow
  const allSet = new Set(game.allWords);
  let completed = true;
  for(const w of allSet){
    if(!game.litWords.has(w)){ completed=false; break; }
  }
  if(completed && !game.hyper){
    triggerHyperflow();
    // reset lit to chase next cycle
    game.litWords.clear();
    game.bumpers.forEach(b=> b.lit=false);
    game.lanes.forEach(l=> l.lit=false);
  }

  // UI
  uiScore.textContent = game.score.toLocaleString('en-US', {minimumIntegerDigits:3});
  uiMult.textContent  = "x"+game.mult.toFixed(2).replace(/\.00$/,'');
  uiTime.textContent  = game.timeLeft.toFixed(1)+"s";
  uiState.textContent = game.running? "PLAY" : (game.timeLeft<=0? "TIME UP" : "PAUSE");
  uiRank.textContent  = game.rank;

  // render
  render();

  requestAnimationFrame(update);
}

/* =========================
   Render
   ========================= */
function render(){
  const shakeX = (Math.random()*2-1) * game.shakes;
  const shakeY = (Math.random()*2-1) * game.shakes;

  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.translate(shakeX, shakeY);

  // playfield glow
  ctx.fillStyle = "#0b0f18";
  ctx.fillRect(0,0,W,H);

// vignette
/*
const vg = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.9);
vg.addColorStop(0, "rgba(0,0,0,0)");
vg.addColorStop(1, "rgba(0,0,0,0.55)");
ctx.fillStyle = vg;
ctx.fillRect(0,0,W,H);
*/

  // frame outline
  ctx.strokeStyle = "rgba(130,180,255,0.35)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(80,1050); ctx.lineTo(720,1050);
  ctx.lineTo(720,120); ctx.lineTo(400,40); ctx.lineTo(80,120); ctx.closePath();
  ctx.stroke();
  ctx.shadowColor = "rgba(130,180,255,0.25)";
  ctx.shadowBlur = 8;
  ctx.stroke();

  // lanes
  for(const l of game.lanes){
    ctx.save();
    ctx.lineWidth = 8;
    const glow = l.lit? 1 : l.glow*0.6;
    ctx.strokeStyle = `hsla(${l.hue} 90% 60% / ${0.25 + glow*0.35})`;
    ctx.beginPath();
    ctx.moveTo(l.x1,l.y1); ctx.lineTo(l.x2,l.y2); ctx.stroke();
    ctx.lineWidth = 2;
    ctx.strokeStyle = `hsla(${l.hue} 90% 70% / ${0.8})`;
    ctx.stroke();
    ctx.font = "700 18px 'Segoe UI', system-ui, Arial";
    ctx.fillStyle = `hsla(${l.hue} 90% 75% / ${l.lit?1:0.5})`;
    const tx = (l.x1+l.x2)/2, ty=(l.y1+l.y2)/2;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(l.word, tx, ty-16);
    ctx.restore();
  }

  // bumpers
  for(const b of game.bumpers){
    ctx.save();
    const lit = b.lit ? 1.0 : 0.0;
    const pulse = b.pulse;
    const r = b.r + pulse*6;
    const hue = b.hue;
    // glow
    const grad = ctx.createRadialGradient(b.x,b.y, r*0.3, b.x,b.y, r*1.4);
    grad.addColorStop(0, `hsla(${hue} 100% 70% / ${0.35 + 0.35*lit})`);
    grad.addColorStop(1, `hsla(${hue} 100% 50% / 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(b.x,b.y, r*1.4, 0, Math.PI*2); ctx.fill();

    // body
    ctx.lineWidth = 3;
    ctx.strokeStyle = `hsla(${hue} 100% 70% / ${0.8})`;
    ctx.fillStyle = `hsla(${hue} 80% 25% / ${0.6})`;
    ctx.beginPath(); ctx.arc(b.x,b.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

    // word
    ctx.font = "700 16px 'Segoe UI', system-ui, Arial";
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle = `hsla(${hue} 100% 85% / ${0.9})`;
    ctx.fillText(b.word, b.x, b.y);
    ctx.restore();
  }

  // spawner channel
  ctx.save();
  ctx.strokeStyle = "rgba(100,180,255,0.35)";
  ctx.lineWidth=5; ctx.beginPath();
  ctx.moveTo(720,1050); ctx.lineTo(720,120); ctx.stroke();
  ctx.restore();

  // flippers
  for(const f of game.flippers){
    ctx.save();
    ctx.translate(f.px, f.py);
    ctx.rotate(f.angle * Math.PI/180);
    // arm
    const hue = f.side==='left'? 190 : 310;
    ctx.fillStyle = `hsla(${hue} 80% 55% / 0.18)`;
    ctx.strokeStyle = `hsla(${hue} 90% 65% / 0.85)`;
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(0,-8); ctx.lineTo(f.len, -6); ctx.lineTo(f.len, 6); ctx.lineTo(0,8);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    // pivot
    ctx.beginPath(); ctx.fillStyle="rgba(255,255,255,0.12)";
    ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // drain light
  ctx.save();
  const dgrad = ctx.createLinearGradient(0,920,0,1100);
  dgrad.addColorStop(0, "rgba(255,255,255,0)");
  dgrad.addColorStop(1, "rgba(255,255,255,0.06)");
  ctx.fillStyle = dgrad;
  ctx.fillRect(80,920, 640, 180);
  ctx.restore();

  // balls
  for(const ball of game.balls){
    // trail
    for(let i=0;i<ball.trail.length;i++){
      const t = ball.trail[i];
      if(t.life<=0) continue;
      const a = t.life * (game.hyper? 0.75 : 0.35);
      const hue = game.hyper? (220 + i*10)%360 : 200;
      ctx.fillStyle = `hsla(${hue} 100% 70% / ${a})`;
      ctx.beginPath(); ctx.arc(t.x, t.y, 10*(1 - i/ball.trail.length), 0, Math.PI*2); ctx.fill();
    }
    // body
    const sheen = ctx.createRadialGradient(ball.x-6, ball.y-6, 2, ball.x, ball.y, ball.r+6);
    sheen.addColorStop(0, "rgba(255,255,255,0.9)");
    sheen.addColorStop(0.15, "rgba(230,240,255,0.7)");
    sheen.addColorStop(1, "rgba(170,190,220,0.15)");
    ctx.fillStyle = sheen;
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.lineWidth=1.5; ctx.stroke();
  }

  // particles
  for(const p of game.particles){
    if(p.type==='spark'){
      ctx.fillStyle = p.color.replace(')', ` / ${clamp(p.life,0,1)})`).replace('hsl','hsla');
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    }else if(p.type==='confetti'){
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate(p.rot + (1-p.life)*2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = clamp(p.life,0,1);
      ctx.fillRect(-p.size/2,-p.size/2, p.size, p.size*1.6);
      ctx.restore();
    }
  }

  // overlay info when not running
  if(!game.running && game.timeLeft>0){
    ctx.save();
    ctx.font = "900 44px 'Segoe UI', system-ui, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.textAlign='center';
    ctx.fillText("NEON PINBALL", W/2, H*0.38);
    ctx.font = "700 18px 'Segoe UI', system-ui, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.fillText("スペースで発射 / ←→ でフリッパー", W/2, H*0.42);
    ctx.restore();
  }

  ctx.restore();



}

/* =========================
   Game loop start
   ========================= */
buildTable();
resetGame();
update();

/* =========================
   Launcher control
   ========================= */
let lastSpace = 0;
function handleLauncher(){
  if(keys.space && game.balls.length>0){
    const t = nowMs();
    if(t - lastSpace > 200){
      lastSpace = t;
      // nudge upward if ball near plunger lane
      const b = game.balls[0];
      if(b && b.x>700 && b.y>880){
        b.vy -= 12; b.vx -= 2;
        AudioSys.beep(520, 0.06, 'square', 200);
      }
    }
  }
}
setInterval(handleLauncher, 30);

/* =========================
   Auto-save guard
   ========================= */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    // soft pause
    game.running = false; uiState.textContent="PAUSE";
  }
});

/* =========================
   Instruction: Start on click
   ========================= */
canvas.addEventListener('click', ()=>{
  if(game.timeLeft<=0) resetGame();
  game.running = true; uiState.textContent="PLAY";
  AudioSys.resume();
});

})();
</script>
</body>
</html>
